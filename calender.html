<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>dorksense // calendar</title>
    <link href="https://cdn.jsdelivr.net/npm/remixicon@3.5.0/fonts/remixicon.css" rel="stylesheet">
    <style>
        /* --- CORE AESTHETICS --- */
        :root {
            --bg-color: #f0f0f0;
            --paper-color: #ffffff;
            --ink-color: #000000;
            --accent-1: #375E97;
            --accent-2: #FB6542;
            --accent-3: #3F681C;
            --border-width: 3px;
            --shadow-offset: 6px;
        }

        body {
            font-family: 'Courier New', Courier, monospace;
            background-color: var(--bg-color);
            color: var(--ink-color);
            margin: 0;
            padding: 20px;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            overflow-x: hidden;
            /* Space for mobile bottom bar */
            padding-bottom: 100px;
        }

        /* --- UTILITIES --- */
        .neo-box {
            background: var(--paper-color);
            border: var(--border-width) solid var(--ink-color);
            box-shadow: var(--shadow-offset) var(--shadow-offset) 0px var(--ink-color);
            transition: all 0.1s ease;
        }

        .no-print {
            display: block;
        }

        /* --- NAVIGATION / BACK LINK --- */
        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 100;
            display: flex;
            align-items: center;
            gap: 5px;
            color: #999;
            /* 普段は薄く目立たない色 */
            text-decoration: none;
            font-weight: bold;
            font-size: 0.9rem;
            transition: all 0.2s ease;
            background: rgba(240, 240, 240, 0.5);
            padding: 5px 10px;
            border-radius: 4px;
        }

        .back-link:hover {
            color: var(--accent-1);
            /* ホバー時にアクセントカラー */
            background: #fff;
            box-shadow: 2px 2px 0 rgba(0, 0, 0, 0.1);
        }

        .back-link i {
            font-size: 1.1rem;
        }

        /* --- LAYOUT STRUCTURE (SCROLLABLE) --- */
        #display-wrapper {
            width: 100%;
            /* 画面幅いっぱいを使う */
            display: flex;
            justify-content: center;
            /* PCでは中央寄せ */
            transform-origin: top center;
            position: relative;
            /* 横スクロールを有効化 */
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            padding-bottom: 20px;
            /* スクロールバーのための余白 */
        }

        /* A4 Page Container (FIXED SIZE, Scaled via JS) */
        .canvas-page {
            /* 縮小せずに固定幅を維持し、JSでscaleする */
            flex: 0 0 210mm;
            width: 210mm;
            min-width: 210mm;
            height: 297mm;
            background: var(--paper-color);
            padding: 2rem;
            box-sizing: border-box;
            position: relative;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            overflow: hidden;
            margin-bottom: 2rem;
            /* Hardware acceleration */
            transform: translateZ(0);
            transform-origin: top center;
            /* Default for PC */
        }

        /* Header Area */
        header {
            flex: 0 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            border-bottom: var(--border-width) solid var(--ink-color);
            padding-bottom: 0.5rem;
        }

        /* Decoration Bar */
        .deco-bar {
            flex: 0 0 auto;
            display: flex;
            gap: 0;
            height: 8px;
            width: 100%;
        }

        /* Calendar Grid Area */
        .calendar-container {
            flex: 0 0 auto;
            display: flex;
            flex-direction: column;
        }

        /* Info/Memo Area */
        .bottom-area {
            flex: 1 1 auto;
            display: grid;
            grid-template-columns: 1fr;
            gap: 1.5rem;
            min-height: 0;
            overflow: hidden;
        }

        .bottom-area .memo-box {
            display: none;
        }

        /* Info Boxes */
        .info-box {
            border: var(--border-width) solid var(--ink-color);
            background: var(--paper-color);
            padding: 0.8rem;
            display: flex;
            flex-direction: column;
            height: 100%;
            box-shadow: 4px 4px 0px var(--ink-color);
            box-sizing: border-box;
            overflow: hidden;
        }

        .info-content-wrapper {
            flex: 1;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* --- TYPOGRAPHY & DECOR --- */
        .meta-info {
            text-align: right;
            font-weight: bold;
            font-size: 1.2rem;
            background: var(--ink-color);
            color: var(--paper-color);
            padding: 0.2rem 0.8rem;
            white-space: nowrap;
        }

        /* --- CALENDAR GRID (Monthly) --- */
        .weekdays {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            border-top: var(--border-width) solid var(--ink-color);
            border-left: var(--border-width) solid var(--ink-color);
            background: var(--ink-color);
        }

        .weekday {
            padding: 0.3rem;
            text-align: center;
            font-weight: 900;
            color: var(--paper-color);
            border-right: var(--border-width) solid var(--ink-color);
            border-bottom: var(--border-width) solid var(--ink-color);
            font-size: 0.9rem;
            text-transform: uppercase;
        }

        .days {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            border-left: var(--border-width) solid var(--ink-color);
            background-color: rgba(204, 255, 0, 0.1);
        }

        .day {
            min-height: 80px;
            border-right: var(--border-width) solid var(--ink-color);
            border-bottom: var(--border-width) solid var(--ink-color);
            background: var(--paper-color);
            position: relative;
            padding: 4px;
            display: flex;
            flex-direction: column;
        }

        /* WEEKEND COLORS (Monthly) */
        .day.saturday .date-num {
            color: var(--accent-1);
        }

        .day.sunday .date-num {
            color: var(--accent-2);
        }

        .date-num {
            font-size: 1.2rem;
            font-weight: 900;
            position: relative;
            z-index: 1;
        }

        .day.today {
            background: var(--accent-1);
        }

        /* Ensure text is readable on "today" highlight if it happens to be weekend */
        .day.today.saturday .date-num,
        .day.today.sunday .date-num {
            color: #fff;
        }

        .day.empty {
            background: repeating-linear-gradient(45deg, #fff, #fff 10px, #eee 10px, #eee 20px);
        }

        .day.range-highlight::before {
            content: '';
            position: absolute;
            left: 0;
            right: 0;
            top: 16px;
            height: 20px;
            background: rgba(251, 101, 66, 0.35);
            transform: translateY(-50%) rotate(-2deg);
            pointer-events: none;
            z-index: 0;
        }

        .day.consumption-start::after {
            content: '消費！';
            position: absolute;
            bottom: 2px;
            right: 2px;
            font-size: 0.6rem;
            font-weight: 900;
            color: var(--accent-3);
            border: 2px solid var(--accent-3);
            padding: 1px 3px;
            z-index: 2;
            background: rgba(255, 255, 255, 0.8);
        }

        /* --- INFO TABLE STYLES (Monthly) --- */
        .box-header {
            font-weight: 900;
            border-bottom: 2px solid var(--ink-color);
            margin-bottom: 0.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex: 0 0 auto;
        }

        .info-split-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(var(--info-card-min, 130px), 1fr));
            gap: 3px;
            width: 100%;
            align-content: start;
        }

        .info-card {
            border: 1px solid #ddd;
            padding: 2px 4px;
            background: #fafafa;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            overflow: hidden;
            font-size: var(--info-font-size, 0.8rem);
        }

        .info-card-name {
            font-weight: bold;
            line-height: 1.15;
        }

        .info-card-qty {
            font-size: 0.85em;
            color: #666;
        }

        .info-card-bar {
            display: flex;
            flex-wrap: wrap;
            font-size: 0.85em;
            line-height: 1;
            letter-spacing: -1px;
            margin-top: 1px;
        }

        .info-card-monthly {
            font-size: 0.9em;
            font-weight: bold;
        }

        /* --- YEARLY GRID & LAYOUT (Revised) --- */
        .yearly-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.5rem;
            /* Gapを少し詰めてカレンダー自体の描画領域を節約 */
            /* Stretch to fill available vertical space */
            flex: 1;
            /* Ensure content stretches to fill height */
            align-content: stretch;
            min-height: 0;
        }

        .mini-month {
            border: var(--border-width) solid var(--ink-color);
            padding: 4px;
            /* Flex layout for vertical stretching */
            display: flex;
            flex-direction: column;
            background: #fff;
        }

        .mini-month-title {
            background: var(--ink-color);
            color: #fff;
            text-align: center;
            font-size: 0.85rem;
            padding: 2px 0;
            font-weight: bold;
            margin-bottom: 2px;
        }

        .mini-weekdays {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            text-align: center;
            font-size: 0.7rem;
            margin-bottom: 2px;
        }

        .mini-weekdays div {
            border-bottom: 2px solid #000;
            font-weight: 900;
        }

        .mini-days {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            text-align: center;
            font-size: 0.8rem;
            /* Fill remaining height in mini-month */
            flex: 1;
            align-content: stretch;
        }

        .mini-day {
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 500;
        }

        .mini-day.has-date {
            font-weight: bold;
        }

        /* WEEKEND COLORS (Yearly) */
        .mini-day.sat {
            color: var(--accent-1);
        }

        .mini-day.sun {
            color: var(--accent-2);
        }

        /* Revised Footer Section for Yearly */
        .footer-section-yearly {
            border: var(--border-width) solid var(--ink-color);
            padding: 0.8rem;
            flex: 0 0 auto;
            background: #f9f9f9;
            box-shadow: 4px 4px 0px var(--ink-color);
        }

        .yearly-stock-grid {
            display: grid;
            /* 6列から5列に減らして1つ1つを広くする */
            grid-template-columns: repeat(5, 1fr);
            gap: 0.5rem;
        }

        .yearly-stock-item {
            border: 2px solid var(--ink-color);
            background: #fff;
            padding: 4px;
            font-size: 0.75rem;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            /* 上寄せにする */
            align-items: center;
            text-align: center;
            box-shadow: 2px 2px 0 rgba(0, 0, 0, 0.1);
        }

        .yearly-stock-item .item-name {
            font-weight: 900;
            font-size: 0.75rem;
            margin-bottom: 2px;
            border-bottom: 1px solid #ccc;
            width: 100%;
            padding-bottom: 1px;

            /* 省略表示を廃止し、折り返しを許可 */
            white-space: normal;
            overflow: visible;
            text-overflow: clip;
            line-height: 1.1;
            min-height: 1.2em;
            /* 最低1行分の高さは確保 */
        }

        .yearly-stock-item .item-qty {
            font-family: monospace;
            font-size: 0.9rem;
            font-weight: bold;
            color: var(--accent-1);
            margin-top: auto;
            /* 数量を常に下部に配置 */
        }

        /* --- CONTROLS: PC Default (Retro Style) --- */
        .controls-pc {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 100;
            width: 160px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .controls-mobile {
            display: none;
            /* Hidden on PC */
        }

        /* PC Button Styles */
        .pc-btn {
            padding: 10px;
            cursor: pointer;
            background: var(--accent-1);
            font-weight: bold;
            border: var(--border-width) solid var(--ink-color);
            box-shadow: 4px 4px 0 var(--ink-color);
            font-family: inherit;
            color: #000;
            font-size: 0.9rem;
            text-align: center;
        }

        .pc-btn:hover {
            background: var(--accent-2);
            color: white;
        }

        .pc-btn.active-mode {
            background: var(--ink-color);
            color: var(--accent-1);
        }

        .pc-month-nav {
            display: flex;
            gap: 5px;
        }

        .pc-month-nav button {
            flex: 1;
        }

        .ctrl-label-pc {
            font-size: 0.8rem;
            font-weight: bold;
            margin-bottom: 5px;
            background: #fff;
            padding: 2px;
            display: inline-block;
        }

        /* --- MOBILE OVERRIDE --- */
        @media (max-width: 768px) {
            body {
                padding: 10px;
                padding-bottom: 100px;
                /* Space for bottom bar */
                /* Change layout to column to place back button naturally */
                flex-direction: column;
                justify-content: flex-start;
                align-items: center;
            }

            /* Scroll Wrapper Mobile Adjustment */
            #display-wrapper {
                justify-content: flex-start;
                /* 左寄せにしてスクロールの起点を合わせる */
                padding-left: 10px;
                padding-right: 10px;
            }

            /* Canvas Transform Origin for Mobile */
            .canvas-page {
                transform-origin: top left;
            }

            /* Back Button Mobile Style */
            .back-link {
                /* Place it in normal flow above calendar */
                position: relative;
                top: auto;
                left: auto;
                align-self: flex-start;
                /* Align to left */
                margin-bottom: 10px;

                background: rgba(255, 255, 255, 0.9);
                border: 1px solid #ccc;
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
                padding: 6px 12px;
                font-size: 0.85rem;
                color: var(--ink-color);
                width: auto;
            }

            .back-link i {
                font-size: 1rem;
            }

            /* Hide PC Controls */
            .controls-pc {
                display: none;
            }

            /* Show Mobile Controls */
            .controls-mobile {
                display: flex;
                position: fixed;
                bottom: 0;
                left: 0;
                width: 100%;
                background: #ffffff;
                border-top: 1px solid #ccc;
                box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
                z-index: 200;
                justify-content: space-around;
                align-items: center;
                padding-bottom: env(safe-area-inset-bottom);
                /* iPhone X+ safe area */
                height: 60px;
            }

            .mobile-tab-btn {
                background: none;
                border: none;
                flex: 1;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                padding: 5px 0;
                cursor: pointer;
                color: #666;
            }

            .mobile-tab-btn:active {
                background-color: #f5f5f5;
            }

            .mobile-tab-btn i {
                font-size: 1.4rem;
                margin-bottom: 2px;
            }

            .mobile-tab-btn span {
                font-size: 0.65rem;
                font-weight: bold;
            }

            .mobile-tab-btn.active-tab {
                color: var(--accent-1);
            }

            .mobile-tab-btn.active-tab i {
                color: var(--accent-1);
            }
        }

        /* --- EDIT MODE STYLES --- */
        .edit-instruction-banner {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 300;
            background: var(--accent-1);
            color: #fff;
            text-align: center;
            padding: 10px 16px;
            font-size: 0.85rem;
            font-weight: bold;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            animation: slideDownBanner 0.3s ease;
        }

        .edit-instruction-banner.visible {
            display: block;
        }

        @keyframes slideDownBanner {
            from {
                transform: translateY(-100%);
            }

            to {
                transform: translateY(0);
            }
        }

        .day-editable {
            cursor: pointer;
            transition: background-color 0.1s;
        }

        .day-editable:hover {
            background-color: rgba(251, 101, 66, 0.1) !important;
        }

        .day-drag-start {
            outline: 3px solid var(--accent-2) !important;
            outline-offset: -3px;
            z-index: 5;
        }

        .day-drag-end {
            outline: 2px dashed var(--accent-2) !important;
            outline-offset: -2px;
            z-index: 4;
            background-color: rgba(251, 101, 66, 0.08) !important;
        }

        .day-drag-preview {
            background-color: rgba(251, 101, 66, 0.1) !important;
        }

        .day-drag-preview::before {
            content: '' !important;
            position: absolute !important;
            left: 0 !important;
            right: 0 !important;
            top: 16px !important;
            height: 20px !important;
            background: rgba(251, 101, 66, 0.25) !important;
            transform: translateY(-50%) !important;
            pointer-events: none !important;
            z-index: 0 !important;
        }

        .edit-mode-active .day:not(.empty) {
            cursor: pointer;
        }

        /* Mobile edit bar button highlight */
        .mobile-tab-btn.edit-active {
            color: var(--accent-2) !important;
            background-color: #fff5f0;
        }

        /* PC edit toggle */
        .pc-btn.edit-active {
            background: var(--accent-2) !important;
            color: #fff !important;
        }

        /* --- PRINT SETTINGS --- */
        #print-container {
            display: none;
        }

        @media print {
            * {
                -webkit-print-color-adjust: exact;
                print-color-adjust: exact;
            }

            body {
                background: #fff;
                padding: 0;
                display: block;
                overflow: visible;
            }

            .controls-pc,
            .controls-mobile,
            .back-link,
            .edit-instruction-banner,
            /* Hide back button on print */
            .no-print,
            #display-wrapper {
                display: none !important;
            }

            /* 印刷時は今日のハイライトを消す */
            .day.today {
                background: var(--paper-color) !important;
            }

            .day.today .date-num {
                color: var(--ink-color) !important;
            }

            .day.today.saturday .date-num {
                color: var(--accent-1) !important;
            }

            .day.today.sunday .date-num {
                color: var(--accent-2) !important;
            }

            #print-container {
                display: block !important;
            }

            @page {
                size: A4 portrait;
                margin: 0;
            }

            .canvas-page {
                margin: 0;
                border: none;
                box-shadow: none;
                page-break-after: always;
                height: 297mm;
                width: 210mm;
                transform: none !important;
            }

            .canvas-page:last-child {
                page-break-after: auto;
            }

            .neo-box {
                box-shadow: none;
                border: 2px solid #000;
            }

            /* 印刷時はINFO欄のオーバーフローを許可し、カードが切り取られないように */
            .bottom-area,
            .info-box,
            .info-content-wrapper {
                overflow: visible !important;
            }

            /* 印刷時もJSで設定した値をそのまま使う（上書きしない） */
        }
    </style>
</head>

<body>

    <!-- Back to Edit Link -->
    <a href="./planner.html" class="back-link no-print">
        <i class="ri-arrow-left-line"></i>
        <span>設定に戻る</span>
    </a>

    <div class="controls-pc no-print">
        <button onclick="handlePrint()" class="pc-btn">印刷</button>
        <div style="height: 10px;"></div>
        <div class="ctrl-label-pc">表示モード:</div>
        <button id="btn-pc-monthly" onclick="switchMode('monthly')" class="pc-btn active-mode">月間</button>
        <button id="btn-pc-yearly" onclick="switchMode('yearly')" class="pc-btn">年間</button>

        <div id="pc-monthly-nav" style="margin-top: 10px;">
            <div class="pc-month-nav">
                <button class="pc-btn" onclick="changeMonth(-1)">&lt;</button>
                <button class="pc-btn" onclick="changeMonth(1)">&gt;</button>
            </div>
            <button onclick="goToToday()" class="pc-btn"
                style="margin-top:5px; background: #fff; color: #000;">今日</button>
        </div>
        <div style="margin-top:15px;">
            <div class="ctrl-label-pc">消費期間:</div>
            <button id="btn-pc-edit" onclick="toggleEditMode()" class="pc-btn">✏️ 編集</button>
        </div>
    </div>

    <div class="controls-mobile no-print">
        <button class="mobile-tab-btn" onclick="changeMonth(-1)">
            <i class="ri-arrow-left-s-line"></i>
            <span>前月</span>
        </button>

        <button class="mobile-tab-btn" onclick="goToToday()">
            <i class="ri-calendar-check-line"></i>
            <span>今日</span>
        </button>

        <button class="mobile-tab-btn" onclick="toggleModeMobile()">
            <i id="mobile-mode-icon" class="ri-layout-grid-fill"></i>
            <span id="mobile-mode-text">年表示へ</span>
        </button>

        <button class="mobile-tab-btn" onclick="changeMonth(1)">
            <i class="ri-arrow-right-s-line"></i>
            <span>次月</span>
        </button>

        <button id="btn-mobile-edit" class="mobile-tab-btn" onclick="toggleEditMode()">
            <i class="ri-edit-2-line"></i>
            <span>編集</span>
        </button>

        <button class="mobile-tab-btn" onclick="handlePrint()" style="color:var(--accent-1);">
            <i class="ri-printer-line"></i>
            <span>印刷</span>
        </button>
    </div>

    <!-- Edit Instruction Banner -->
    <div id="edit-banner" class="edit-instruction-banner">
        消費開始日をクリック（タップ）し、ドラッグ（スライド）して消費期間を選択してください
        <button onclick="cancelEditMode()"
            style="margin-left:12px; background:#fff; color:var(--accent-1); border:none; padding:4px 12px; border-radius:4px; font-weight:bold; cursor:pointer;">キャンセル</button>
    </div>

    <div id="display-wrapper">
        <div id="screen-canvas" class="canvas-page neo-box">
        </div>
    </div>

    <div id="print-container"></div>

    <script>
        let currentDate = new Date();
        let viewMode = 'monthly';

        // STOCK ITEMS
        let STOCK_ITEMS = [
            { name: "水", count: 3, unit: "L" },
            { name: "レトルトご飯", count: 2.1, unit: "食" },
            { name: "レトルト食品", count: 2, unit: "食" },
            { name: "缶詰", count: 1.3, unit: "缶" },
            { name: "乾麺類", count: 1.6, unit: "個" },
            { name: "野菜ジュース", count: 1, unit: "本" },
            { name: "栄養バー", count: 2, unit: "個" },
            { name: "健康飲料粉末", count: 1, unit: "個" },
            { name: "無洗米", count: 2, unit: "kg" },
            { name: "お菓子", count: 1, unit: "個" },
            { name: "果物缶詰", count: 0.8, unit: "個" },
            { name: "乾物", count: 0.4, unit: "個" },
            { name: "ドライフルーツ", count: 0.4, unit: "袋" },
        ];

        let highlightPayload = {
            startDate: new Date().toISOString().split('T')[0].replace(/-/g, '/'),
            days: 3,
            adults: 2,
            children: 0,
            weekNumber: 2,
            weekDay: 2
        };

        function loadExternalData() {
            const bridgeDataRaw = localStorage.getItem('dorksense_bridge_data');
            if (bridgeDataRaw) {
                try {
                    const bridgeData = JSON.parse(bridgeDataRaw);
                    if (bridgeData.household) {
                        highlightPayload.adults = bridgeData.household.adults;
                        highlightPayload.children = bridgeData.household.children;
                        highlightPayload.days = bridgeData.household.days;
                        if (bridgeData.household.weekNumber !== undefined) {
                            highlightPayload.weekNumber = bridgeData.household.weekNumber;
                        }
                        if (bridgeData.household.weekDay !== undefined) {
                            highlightPayload.weekDay = bridgeData.household.weekDay;
                        }
                    }
                    if (bridgeData.items && Array.isArray(bridgeData.items)) {
                        STOCK_ITEMS = bridgeData.items;
                    }
                } catch (e) {
                    console.error("Failed to parse bridge data", e);
                }
            }
        }

        function setupHighlightRange() {
            const params = new URLSearchParams(window.location.search);
            const pStart = params.get('start');
            const pDays = params.get('days');
            const pAdults = params.get('adults');
            const pChildren = params.get('children');
            const pWeekNum = params.get('weekNumber');
            const pWeekDay = params.get('weekDay');

            if (pStart) highlightPayload.startDate = pStart.replace(/-/g, '/');
            if (pDays) highlightPayload.days = parseInt(pDays, 10);
            if (pAdults) highlightPayload.adults = parseInt(pAdults, 10);
            if (pChildren) highlightPayload.children = parseInt(pChildren, 10);
            if (pWeekNum) highlightPayload.weekNumber = parseInt(pWeekNum, 10);
            if (pWeekDay) highlightPayload.weekDay = parseInt(pWeekDay, 10);

            const normalized = highlightPayload.startDate.replace(/\//g, '-');
            const [y, m, d] = normalized.split('-').map(Number);
            currentDate = new Date(y, m - 1, 1);
        }

        function isConsumptionPeriod(year, month, day) {
            const startDay = getNthWeekDay(year, month, highlightPayload.weekNumber, highlightPayload.weekDay);
            if (!startDay) return false;
            const startDate = new Date(year, month, startDay);
            const endDate = new Date(startDate);
            endDate.setDate(startDate.getDate() + highlightPayload.days);
            const current = new Date(year, month, day);
            current.setHours(0, 0, 0, 0); startDate.setHours(0, 0, 0, 0); endDate.setHours(0, 0, 0, 0);
            return current >= startDate && current < endDate;
        }

        function isConsumptionStartDate(year, month, day) {
            const startDay = getNthWeekDay(year, month, highlightPayload.weekNumber, highlightPayload.weekDay);
            return startDay === day;
        }

        function getNthWeekDay(year, month, weekNumber, weekDay) {
            const firstDayOfMonth = new Date(year, month, 1);
            const dayOfWeek = firstDayOfMonth.getDay();
            let day = 1 + (weekDay - dayOfWeek + 7) % 7;
            day += (weekNumber - 1) * 7;
            const daysInMonth = new Date(year, month + 1, 0).getDate();
            if (day > daysInMonth) return null;
            return day;
        }

        const MONTHS = ["１月", "２月", "３月", "４月", "５月", "６月", "７月", "８月", "９月", "１０月", "１１月", "１２月"];

        function init() {
            loadExternalData();
            setupHighlightRange();
            renderScreen();
            adjustMobileScale(); // Initial adjustment
            window.addEventListener('resize', adjustMobileScale); // Adjust on resize
        }

        // --- MOBILE SCALING LOGIC (FIXED HEIGHT, SCROLL WIDTH) ---
        function adjustMobileScale() {
            const canvas = document.getElementById('screen-canvas');
            const wrapper = document.getElementById('display-wrapper');

            // PC: Reset styles
            if (window.innerWidth > 768) {
                canvas.style.transform = '';
                canvas.style.marginBottom = '';
                canvas.style.marginRight = '';
                wrapper.style.height = '';
                return;
            }

            // Mobile: Calculate Scale based on Height to avoid vertical scroll
            // UI Offset: Mobile Controls (~60px) + Back Button/Header (~80px) + Padding
            const uiOffset = 150;
            const availableHeight = window.innerHeight - uiOffset;
            const originalHeight = canvas.offsetHeight; // Should be ~1122px (297mm)
            const originalWidth = canvas.offsetWidth;   // Should be ~793px (210mm)

            // Calculate scale ratio to fit height
            let scale = availableHeight / originalHeight;

            // LIMITS: Don't make it too small (unreadable).
            // 0.5 is reasonable minimum (A4 becomes A6 size roughly)
            if (scale < 0.5) scale = 0.5;
            if (scale > 1) scale = 1;

            // Apply Transform
            canvas.style.transform = `scale(${scale})`;

            // FIX LAYOUT GAP caused by scaling
            // Transform doesn't affect flow, so we must manually reduce spacing
            // Negative margin pulls the bottom/right space back
            const gapH = originalHeight * (1 - scale);
            const gapW = originalWidth * (1 - scale);

            canvas.style.marginBottom = `-${gapH}px`;
            canvas.style.marginRight = `-${gapW}px`;

            // Adjust Wrapper to contain the SCALED size
            // We set height explicitly to ensure container fits the visual size
            wrapper.style.height = (originalHeight * scale) + 'px';

            // If scaled width is less than screen width, center it (via flex in CSS)
            // If scaled width is more than screen width, left align (via CSS left-align default for scroll)
            // No extra JS needed for centering as parent has justify-content: start/center logic via margin
        }

        // --- RENDER LOGIC ---
        function generateMonthlyPageHTML(year, month) {
            const firstDay = new Date(year, month, 1).getDay();
            let startSlot = firstDay - 1;
            if (startSlot === -1) startSlot = 6;
            const daysInMonth = new Date(year, month + 1, 0).getDate();
            const monthName = MONTHS[month];

            const totalSlots = startSlot + daysInMonth;
            const weeksCount = Math.ceil(totalSlots / 7);

            let bottomAreaClass = 'bottom-area wide-mode';

            let daysHTML = '';
            for (let i = 0; i < startSlot; i++) daysHTML += `<div class="day empty"></div>`;

            const today = new Date();
            for (let d = 1; d <= daysInMonth; d++) {
                let classes = 'day';
                // Calculate day of week for coloring
                const currentDayDate = new Date(year, month, d);
                const dayOfWeek = currentDayDate.getDay();
                if (dayOfWeek === 6) classes += ' saturday';
                if (dayOfWeek === 0) classes += ' sunday';

                if (year === today.getFullYear() && month === today.getMonth() && d === today.getDate()) classes += ' today';
                if (isConsumptionPeriod(year, month, d)) {
                    classes += ' range-highlight';
                    if (isConsumptionStartDate(year, month, d)) classes += ' consumption-start';
                }
                daysHTML += `<div class="${classes}" data-day="${d}" data-year="${year}" data-month="${month}"><span class="date-num">${d < 10 ? '0' + d : d}</span></div>`;
            }

            const remaining = (weeksCount * 7) - totalSlots;
            for (let i = 0; i < remaining; i++) daysHTML += `<div class="day empty" style="opacity:0.3"></div>`;

            let infoContentHtml = '';
            const weightedPeople = highlightPayload.adults + (highlightPayload.children * 0.6);
            const days = highlightPayload.days;
            const weeksJP = ["日", "月", "火", "水", "木", "金", "土"];

            const itemCount = STOCK_ITEMS.length;

            infoContentHtml += `
                <div class="info-header-line" style="font-size:0.85rem; font-weight:bold; margin-bottom:3px;">
                    設定: 大人${highlightPayload.adults}人 子供${highlightPayload.children}人 × ${days}日分
                    <span style="font-weight:normal; font-size:0.8rem; margin-left:8px;">消費: 第${highlightPayload.weekNumber}${weeksJP[highlightPayload.weekDay]}曜</span>
                    <span style="font-weight:normal; font-size:0.75rem; margin-left:8px; color:#666;">品目数: ${itemCount}</span>
                </div>
            `;

            const b = (c, col, op = 1) => `<span style="color:${col};opacity:${op};">${c}</span>`;

            let cardsHtml = '';
            STOCK_ITEMS.forEach(item => {
                const totalQty = item.isTotal
                    ? item.count
                    : Math.ceil(item.count * weightedPeople * days);
                const accCurrent = Math.floor(((month + 1) * totalQty) / 12);
                const accPrev = Math.floor((month * totalQty) / 12);
                let monthlyQty = accCurrent - accPrev;

                let visualBar = '';
                for (let k = 0; k < accPrev; k++) visualBar += b('◆', 'var(--ink-color)', 0.5);
                for (let k = 0; k < monthlyQty; k++) visualBar += b('◆', 'var(--accent-2)');
                for (let k = 0; k < (totalQty - accCurrent); k++) visualBar += b('◇', '#ccc');

                cardsHtml += `
                    <div class="info-card">
                        <div class="info-card-name">${item.name}</div>
                        <div class="info-card-qty">総 ${totalQty}${item.unit}</div>
                        <div class="info-card-bar">${visualBar}</div>
                        <div class="info-card-monthly">今月:${monthlyQty}${item.unit}</div>
                    </div>
                `;
            });

            infoContentHtml += `<div class="info-split-container">${cardsHtml}</div>`;

            return `
                <header>
                    <div class="meta-info">${year} // ${monthName}</div>
                </header>
                <div class="deco-bar">
                    <div style="background:var(--ink-color);width:70%;"></div>
                    <div style="background:var(--accent-1);width:15%;"></div>
                    <div style="background:var(--accent-2);width:15%;"></div>
                </div>
                <div class="calendar-container">
                    <div class="weekdays">
                        <div class="weekday">月曜</div><div class="weekday">火曜</div><div class="weekday">水曜</div>
                        <div class="weekday">木曜</div><div class="weekday">金曜</div>
                        <div class="weekday" style="color:var(--accent-1)">土曜</div><div class="weekday" style="color:var(--accent-2)">日曜</div>
                    </div>
                    <div class="days">
                        ${daysHTML}
                    </div>
                </div>
                <div class="${bottomAreaClass}">
                    <div class="info-box">
                        <div class="box-header"><span>INFO</span><span style="font-size:0.7rem;">[DATA]</span></div>
                        <div class="info-content-wrapper">${infoContentHtml}</div>
                    </div>
                </div>
                <div style="position:absolute;bottom:10px;right:10px;font-size:0.6rem;opacity:0.7;writing-mode:vertical-rl;">DS_CAL_M_${year}_${month + 1}</div>
            `;
        }

        function generateYearlyPageHTML(year) {
            let gridHTML = '';
            for (let m = 0; m < 12; m++) {
                const firstDay = new Date(year, m, 1).getDay();
                let startSlot = firstDay - 1;
                if (startSlot === -1) startSlot = 6;
                const daysInMonth = new Date(year, m + 1, 0).getDate();
                let miniDays = '';
                for (let s = 0; s < startSlot; s++) miniDays += `<div class="mini-day"></div>`;

                for (let d = 1; d <= daysInMonth; d++) {
                    const currentDayDate = new Date(year, m, d);
                    const dayOfWeek = currentDayDate.getDay();
                    let dayClass = 'mini-day has-date';
                    if (dayOfWeek === 6) dayClass += ' sat';
                    if (dayOfWeek === 0) dayClass += ' sun';

                    miniDays += `<div class="${dayClass}">${d}</div>`;
                }

                gridHTML += `<div class="mini-month"><div class="mini-month-title">${MONTHS[m]}</div>
                    <div class="mini-weekdays"><div>月</div><div>火</div><div>水</div><div>木</div><div>金</div><div style="color:var(--accent-1)">土</div><div style="color:var(--accent-2)">日</div></div>
                    <div class="mini-days">${miniDays}</div></div>`;
            }

            let stockListHTML = '';
            const weightedPeople = highlightPayload.adults + (highlightPayload.children * 0.6);
            const days = highlightPayload.days;
            STOCK_ITEMS.forEach(item => {
                const totalQty = item.isTotal
                    ? item.count
                    : Math.ceil(item.count * weightedPeople * days);
                stockListHTML += `
                <div class="yearly-stock-item">
                    <div class="item-name">${item.name}</div>
                    <div class="item-qty">${totalQty}<span style="font-size:0.7em;">${item.unit}</span></div>
                </div>`;
            });

            return `
                <header><div class="meta-info">${year} // YEARLY</div></header>
                <div class="deco-bar"><div style="background:var(--ink-color);width:100%;"></div></div>
                <div class="yearly-grid">${gridHTML}</div>
                <div class="footer-section-yearly">
                    <div style="font-weight:bold;border-bottom:2px solid var(--ink-color);margin-bottom:8px; display:flex; justify-content:space-between;">
                        <span>STOCK LIST (YEARLY GOAL)</span>
                        <span style="font-size:0.8em; font-weight:normal;">[備蓄目標総量 / ${STOCK_ITEMS.length}品目]</span>
                    </div>
                    <div class="yearly-stock-grid">${stockListHTML}</div>
                </div>
            `;
        }

        function renderScreen() {
            const screenCanvas = document.getElementById('screen-canvas');
            const year = currentDate.getFullYear();
            const month = currentDate.getMonth();

            if (viewMode === 'monthly') {
                screenCanvas.innerHTML = generateMonthlyPageHTML(year, month);
                // レンダリング後にINFO欄のフォントを自動調整
                requestAnimationFrame(() => autoFitInfoCards());
                document.getElementById('pc-monthly-nav').style.display = 'block';
                // Show edit buttons in monthly view
                if (document.getElementById('btn-pc-edit')) document.getElementById('btn-pc-edit').parentElement.style.display = '';
                if (document.getElementById('btn-mobile-edit')) document.getElementById('btn-mobile-edit').style.display = '';
                // Mobile Text Update
                document.getElementById('mobile-mode-text').innerText = '年表示へ';
                document.getElementById('mobile-mode-icon').className = 'ri-layout-grid-fill';
            } else {
                screenCanvas.innerHTML = generateYearlyPageHTML(year);
                document.getElementById('pc-monthly-nav').style.display = 'none';
                // Hide edit buttons in yearly view
                if (document.getElementById('btn-pc-edit')) document.getElementById('btn-pc-edit').parentElement.style.display = 'none';
                if (document.getElementById('btn-mobile-edit')) document.getElementById('btn-mobile-edit').style.display = 'none';
                // Mobile Text Update
                document.getElementById('mobile-mode-text').innerText = '月表示へ';
                document.getElementById('mobile-mode-icon').className = 'ri-calendar-check-line';
            }
            adjustMobileScale(); // Re-calculate on render
        }

        function autoFitInfoCards() {
            const wrapper = document.querySelector('#screen-canvas .info-content-wrapper');
            const grid = wrapper ? wrapper.querySelector('.info-split-container') : null;
            if (wrapper && grid) autoFitInfoCardsFor(wrapper, grid);
        }

        /**
         * INFO欄カードの最適サイズ計算（px基準・2フェーズ選択）
         * 
         * Phase 1: 各カラム数(3~6)に対し、カード内に収まる最大フォントサイズ(rawFontPx)を算出
         * Phase 2: rawFontPxが最大のカラム数を選択
         *   - 複数が同じクランプ値になった場合、少ないカラム（広いカード）を優先
         *   - スペースが厳しい時は多いカラム（少ない行数）が自然に勝つ
         */
        function autoFitInfoCardsFor(wrapper, grid) {
            const cards = grid.querySelectorAll('.info-card');
            const itemCount = cards.length;
            if (itemCount === 0) return;

            // ヘッダー行の高さを引いた使用可能な高さ
            const headerLine = wrapper.querySelector('.info-header-line');
            const headerH = headerLine ? headerLine.offsetHeight + 3 : 0;
            const availableH = wrapper.clientHeight - headerH;
            const availableW = wrapper.clientWidth;

            if (availableH <= 0 || availableW <= 0) return;

            const MIN_COLS = 3, MAX_COLS = 6;
            const MIN_FONT_PX = 8, MAX_FONT_PX = 14;
            const gap = 3;

            // 各品目のバー記号の総数と品名の最大長を取得
            const weightedPeople = highlightPayload.adults + (highlightPayload.children * 0.6);
            const days = highlightPayload.days;
            let maxBarSymbols = 0;
            let maxNameLen = 0;
            STOCK_ITEMS.forEach(item => {
                const totalQty = item.isTotal
                    ? item.count
                    : Math.ceil(item.count * weightedPeople * days);
                if (totalQty > maxBarSymbols) maxBarSymbols = totalQty;
                if (item.name.length > maxNameLen) maxNameLen = item.name.length;
            });

            // Phase 1: 各カラム数のrawFontPxを計算
            const candidates = [];
            for (let cols = MIN_COLS; cols <= MAX_COLS; cols++) {
                const rows = Math.ceil(itemCount / cols);
                const cardW = (availableW - gap * (cols - 1)) / cols;
                const maxCardH = (availableH - gap * (rows - 1)) / rows;

                if (maxCardH <= 0 || cardW < 60) continue;

                // カード内行数を推定
                const testFontPx = Math.min(MAX_FONT_PX, Math.max(MIN_FONT_PX, maxCardH / 4));
                const charWidthPx = testFontPx * 0.85;
                const usableCardW = cardW - 8; // padding分

                // バー記号の折返し行数（最大2行に制限 — バーは装飾的要素）
                const barsPerLine = Math.max(1, Math.floor(usableCardW / (charWidthPx * 0.6)));
                const barLines = Math.min(2, Math.ceil(maxBarSymbols / barsPerLine));
                const nameLines = (maxNameLen > 5 && usableCardW < testFontPx * maxNameLen * 0.7) ? 2 : 1;

                // 総行数: 品名 + 数量 + バー + 月量 + 余裕
                const totalLines = nameLines + 1 + Math.max(1, barLines) + 1 + 0.3;
                const lineHeight = 1.3;

                // 行数からフォントサイズを逆算 (px) — クランプしない生の値
                const rawFontPx = maxCardH / (totalLines * lineHeight);

                candidates.push({ cols, rows, rawFontPx, cardW, maxCardH, totalLines });
            }

            if (candidates.length === 0) return;

            // Phase 2: 最適なカラム数を選択
            // rawFontPxをクランプした値で比較し、同値なら少ないカラム（広いカード）を優先
            let bestCols = candidates[0].cols;
            let bestRawFont = candidates[0].rawFontPx;

            for (const c of candidates) {
                const clampedCurrent = Math.max(MIN_FONT_PX, Math.min(MAX_FONT_PX, c.rawFontPx));
                const clampedBest = Math.max(MIN_FONT_PX, Math.min(MAX_FONT_PX, bestRawFont));

                if (clampedCurrent > clampedBest) {
                    // クランプ後のフォントが大きい → 明確に優れている
                    bestCols = c.cols;
                    bestRawFont = c.rawFontPx;
                } else if (clampedCurrent === clampedBest) {
                    // クランプ後が同じ場合：
                    // 両方ともMAXにクランプ → 少ないカラム（広いカード）を優先
                    // 両方ともMINにクランプ → rawFontPxが大きい方（はみ出しが少ない）を優先
                    if (clampedCurrent >= MAX_FONT_PX) {
                        // 十分な高さがある → 少ないカラムで大きく表示
                        if (c.cols < bestCols) {
                            bestCols = c.cols;
                            bestRawFont = c.rawFontPx;
                        }
                    } else {
                        // スペースが厳しい → rawFontPxが大きい方（＝多いカラム＝少ない行数）
                        if (c.rawFontPx > bestRawFont) {
                            bestCols = c.cols;
                            bestRawFont = c.rawFontPx;
                        }
                    }
                }
            }

            const bestFontPx = Math.max(MIN_FONT_PX, Math.min(MAX_FONT_PX, bestRawFont));

            // px → rem 変換 (実際のルートfont-sizeを取得)
            const rootFontSize = parseFloat(getComputedStyle(document.documentElement).fontSize) || 16;
            const bestFontRem = bestFontPx / rootFontSize;

            grid.style.setProperty('--info-font-size', bestFontRem.toFixed(3) + 'rem');
            grid.style.gridTemplateColumns = `repeat(${bestCols}, 1fr)`;
        }

        function switchMode(mode) {
            // 年間表示に切り替える際は編集モードをキャンセル
            if (mode === 'yearly' && editMode) {
                exitEditMode();
            }
            viewMode = mode;
            // Update PC Buttons
            document.getElementById('btn-pc-monthly').className = mode === 'monthly' ? 'pc-btn active-mode' : 'pc-btn';
            document.getElementById('btn-pc-yearly').className = mode === 'yearly' ? 'pc-btn active-mode' : 'pc-btn';
            renderScreen();
        }

        function toggleModeMobile() {
            switchMode(viewMode === 'monthly' ? 'yearly' : 'monthly');
        }

        function changeMonth(step) {
            currentDate.setMonth(currentDate.getMonth() + step);
            renderScreen();
        }

        function goToToday() {
            currentDate = new Date();
            renderScreen();
        }

        function handlePrint() {
            const printContainer = document.getElementById('print-container');
            printContainer.innerHTML = '';
            const year = currentDate.getFullYear();

            // 常に今日の月～12月 + 年間の両方を印刷
            const todayMonth = new Date().getMonth();
            for (let m = todayMonth; m < 12; m++) {
                printContainer.innerHTML += `<div class="canvas-page neo-box" style="margin:0; border:none; box-shadow:none;">${generateMonthlyPageHTML(year, m)}</div>`;
            }
            // 年間ページを最後に追加
            printContainer.innerHTML += `<div class="canvas-page neo-box" style="margin:0; border:none; box-shadow:none;">${generateYearlyPageHTML(year)}</div>`;

            // 印刷コンテナを一時的に表示してJS計測を可能にする
            printContainer.style.display = 'block';
            printContainer.style.position = 'absolute';
            printContainer.style.left = '-9999px';
            printContainer.style.top = '0';

            // 各月ページのINFO欄にautoFitInfoCardsForを適用
            requestAnimationFrame(() => {
                printContainer.querySelectorAll('.canvas-page').forEach(page => {
                    const w = page.querySelector('.info-content-wrapper');
                    const g = w ? w.querySelector('.info-split-container') : null;
                    if (w && g) autoFitInfoCardsFor(w, g);
                });

                // 計測完了後、非表示に戻してから印刷
                printContainer.style.position = '';
                printContainer.style.left = '';
                printContainer.style.top = '';
                // display:blockのままにする（印刷CSSが制御する）

                setTimeout(() => {
                    window.print();
                    // 印刷後にコンテナを非表示に戻す
                    printContainer.style.display = 'none';
                }, 100);
            });
        }

        // =========================================
        // CONSUMPTION PERIOD EDITING
        // =========================================
        let editMode = false;
        let dragStartDay = null;
        let dragCurrentDay = null;
        let isDragging = false;

        function toggleEditMode() {
            if (editMode) {
                exitEditMode();
            } else {
                enterEditMode();
            }
        }

        function enterEditMode() {
            if (viewMode !== 'monthly') {
                switchMode('monthly');
            }
            editMode = true;
            dragStartDay = null;
            dragCurrentDay = null;
            isDragging = false;

            // Show instruction banner
            document.getElementById('edit-banner').classList.add('visible');

            // Highlight edit buttons
            const pcBtn = document.getElementById('btn-pc-edit');
            const mobileBtn = document.getElementById('btn-mobile-edit');
            if (pcBtn) pcBtn.classList.add('edit-active');
            if (mobileBtn) mobileBtn.classList.add('edit-active');

            // Add edit-mode class to canvas
            document.getElementById('screen-canvas').classList.add('edit-mode-active');

            // Disable mobile scroll during edit
            const wrapper = document.getElementById('display-wrapper');
            wrapper.style.overflowX = 'hidden';

            attachDayListeners();
        }

        function exitEditMode() {
            editMode = false;
            dragStartDay = null;
            dragCurrentDay = null;
            isDragging = false;

            // Hide instruction banner
            document.getElementById('edit-banner').classList.remove('visible');

            // Remove edit button highlights
            const pcBtn = document.getElementById('btn-pc-edit');
            const mobileBtn = document.getElementById('btn-mobile-edit');
            if (pcBtn) pcBtn.classList.remove('edit-active');
            if (mobileBtn) mobileBtn.classList.remove('edit-active');

            // Remove edit-mode class
            document.getElementById('screen-canvas').classList.remove('edit-mode-active');

            // Restore mobile scroll
            const wrapper = document.getElementById('display-wrapper');
            wrapper.style.overflowX = '';

            clearDragPreview();
        }

        function cancelEditMode() {
            exitEditMode();
        }

        function attachDayListeners() {
            const dayCells = document.querySelectorAll('#screen-canvas .day:not(.empty)');

            dayCells.forEach(cell => {
                cell.classList.add('day-editable');

                // --- PC: Mouse Events ---
                cell.addEventListener('mousedown', onDayMouseDown);
                cell.addEventListener('mouseover', onDayMouseOver);
            });

            // mouseup on document to capture release anywhere
            document.addEventListener('mouseup', onDayMouseUp);

            // --- Mobile: Touch Events ---
            const canvas = document.getElementById('screen-canvas');
            canvas.addEventListener('touchstart', onTouchStart, { passive: false });
            canvas.addEventListener('touchmove', onTouchMove, { passive: false });
            canvas.addEventListener('touchend', onTouchEnd, { passive: false });
        }

        function getDayFromCell(cell) {
            if (!cell || !cell.dataset.day) return null;
            return parseInt(cell.dataset.day);
        }

        // --- PC Mouse Handlers ---
        function onDayMouseDown(e) {
            if (!editMode) return;
            e.preventDefault();
            const day = getDayFromCell(this);
            if (day === null) return;
            isDragging = true;
            dragStartDay = day;
            dragCurrentDay = day;
            updateDragPreview();
        }

        function onDayMouseOver(e) {
            if (!editMode || !isDragging) return;
            const day = getDayFromCell(this);
            if (day === null) return;
            dragCurrentDay = day;
            updateDragPreview();
        }

        function onDayMouseUp(e) {
            if (!editMode || !isDragging) return;
            isDragging = false;
            if (dragStartDay !== null && dragCurrentDay !== null) {
                applyDragSelection();
            }
        }

        // --- Mobile Touch Handlers ---
        function getDayCellFromPoint(x, y) {
            const el = document.elementFromPoint(x, y);
            if (!el) return null;
            // Walk up to find .day element
            let cell = el.closest('.day:not(.empty)');
            return cell;
        }

        function onTouchStart(e) {
            if (!editMode) return;
            const touch = e.touches[0];
            const cell = getDayCellFromPoint(touch.clientX, touch.clientY);
            if (!cell) return;
            e.preventDefault();
            const day = getDayFromCell(cell);
            if (day === null) return;
            isDragging = true;
            dragStartDay = day;
            dragCurrentDay = day;
            updateDragPreview();
        }

        function onTouchMove(e) {
            if (!editMode || !isDragging) return;
            e.preventDefault();
            const touch = e.touches[0];
            const cell = getDayCellFromPoint(touch.clientX, touch.clientY);
            if (!cell) return;
            const day = getDayFromCell(cell);
            if (day === null) return;
            dragCurrentDay = day;
            updateDragPreview();
        }

        function onTouchEnd(e) {
            if (!editMode || !isDragging) return;
            e.preventDefault();
            isDragging = false;
            if (dragStartDay !== null && dragCurrentDay !== null) {
                applyDragSelection();
            }
        }

        // --- Drag Preview ---
        function updateDragPreview() {
            clearDragPreview();
            if (dragStartDay === null || dragCurrentDay === null) return;

            const minDay = Math.min(dragStartDay, dragCurrentDay);
            const maxDay = Math.max(dragStartDay, dragCurrentDay);

            const dayCells = document.querySelectorAll('#screen-canvas .day:not(.empty)');
            dayCells.forEach(cell => {
                const d = getDayFromCell(cell);
                if (d === null) return;
                if (d >= minDay && d <= maxDay) {
                    cell.classList.add('day-drag-preview');
                }
                if (d === dragStartDay) {
                    cell.classList.add('day-drag-start');
                }
                if (d === dragCurrentDay && dragCurrentDay !== dragStartDay) {
                    cell.classList.add('day-drag-end');
                }
            });
        }

        function clearDragPreview() {
            document.querySelectorAll('.day-drag-preview').forEach(el => el.classList.remove('day-drag-preview'));
            document.querySelectorAll('.day-drag-start').forEach(el => el.classList.remove('day-drag-start'));
            document.querySelectorAll('.day-drag-end').forEach(el => el.classList.remove('day-drag-end'));
            document.querySelectorAll('.day-editable').forEach(el => el.classList.remove('day-editable'));
        }

        // --- Apply Selection ---
        function applyDragSelection() {
            const minDay = Math.min(dragStartDay, dragCurrentDay);
            const maxDay = Math.max(dragStartDay, dragCurrentDay);
            const selectedDays = maxDay - minDay + 1;

            const year = currentDate.getFullYear();
            const month = currentDate.getMonth();
            const startDate = new Date(year, month, minDay);
            const startDayOfWeek = startDate.getDay(); // 0=Sun, 1=Mon...

            // Calculate which week number this falls in
            const firstOfMonth = new Date(year, month, 1);
            const firstDayOfWeek = firstOfMonth.getDay();
            // week number = which occurrence of this weekday in the month
            let weekNum = 1;
            let checkDay = 1 + (startDayOfWeek - firstDayOfWeek + 7) % 7;
            while (checkDay + 7 <= minDay) {
                checkDay += 7;
                weekNum++;
            }

            // Update highlightPayload
            highlightPayload.weekNumber = weekNum;
            highlightPayload.weekDay = startDayOfWeek;
            highlightPayload.days = selectedDays;

            // Also update bridge data so it persists
            const bridgeDataRaw = localStorage.getItem('dorksense_bridge_data');
            if (bridgeDataRaw) {
                try {
                    const bridgeData = JSON.parse(bridgeDataRaw);
                    if (!bridgeData.household) bridgeData.household = {};
                    bridgeData.household.weekNumber = weekNum;
                    bridgeData.household.weekDay = startDayOfWeek;
                    bridgeData.household.days = selectedDays;
                    localStorage.setItem('dorksense_bridge_data', JSON.stringify(bridgeData));
                } catch (e) {
                    console.error('Failed to update bridge data', e);
                }
            }

            // Exit edit mode and re-render
            exitEditMode();
            renderScreen();
        }

        init();
    </script>
</body>

</html>